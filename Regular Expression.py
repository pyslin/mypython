#用\d可以匹配一个数字，\w可以匹配一个字母或数字
#'00\d'可以匹配'007'，但无法匹配'00A'；
#'00\d'可以匹配'007'，但无法匹配'00A'；

# .可以匹配任意字符，所以：
# 'py.'可以匹配'pyc'、'pyo'、'py!'等等。

#用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：
# \d{3}\s+\d{3,8}
#\d{3}表示匹配3个数字，例如'010'；
#\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
#\d{3,8}表示3-8个数字，例如'1234567'。
#上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。


#\转义 \n 换行 \s 空格

#要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是\d{3}\-\d{3,8}

#可以用[]表示范围
#[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等
#A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'

#^表示行的开头，^\d表示必须以数字开头。
# $表示行的结束，\d$表示必须以数字结束。

"""
强烈建议使用Python的r前缀，就不用考虑转义的问题了：
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'
"""
import re
print(re.match(r'^\d{3}\-\d{3,8}$','010-12345'))
print(re.match(r'^\d{3}\-\d{3,8}$','010-12345'))

test ='010-12345'
if re.match(r'^\d{3}\-\d{3,8}$',test):
    print('ok')
else:
    print('failed')

print('a b  c'.split(' '))

print(re.split(r'\s+','a b  c'))

#无论多少个空格都可以正常分割。加入,试试：
print(re.split(r'[\s\,]+', 'a,b, c  d'))
print(re.split(r'[\s\,\;]+','a,b;;c  d'))

m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print(m)
print(m.group(0))
print(m.group(1),m.group(2))
#注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。\

#如果一个正则表达式要重复使用几千次，出于效率的考虑，
# 我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹
import re
#编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
#使用
print('###')
#group()方法和groups方法是不一样的
#print(re_telephone.match('010-12345').group())
print(re_telephone.match('010-12345').groups())



